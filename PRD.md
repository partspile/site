# Product Requirements Document (PRD)

## Project: Parts Pile

---

## 1. Overview

Parts Pile is a web-based platform for listing, searching, and managing automotive parts ads. It provides a structured, vehicle-centric approach to cataloging parts, allowing users to filter and search by make, year, model, engine, category, and subcategory. The system is backed by a normalized vehicle/parts database and supports CRUD operations for ads, as well as a rich vehicle data model. The platform serves both sellers (listing parts) and buyers (searching for parts).

---

## 2. Goals & Objectives

- Enable users to list and manage ads for automotive parts with detailed vehicle fitment data.
- Provide powerful, structured search and filtering by vehicle (make, year, model, engine) and part (category, subcategory).
- Support a modern, responsive UI for ad creation, editing, and browsing.
- Maintain a comprehensive, normalized database of vehicles and parts.
- Allow for future extensibility (e.g., more part attributes, user accounts, messaging).

---

## 3. Features

### 3.1 Ad Management
- Users can create, edit, and delete ads for automotive parts.
- Each ad includes: description, price, vehicle fitment (make, year(s), model(s), engine(s)), part category, and subcategory.
- Ads are timestamped.

### 3.2 Vehicle Data Integration
- The system maintains a comprehensive, normalized vehicle database (make, year, model, engine) to support accurate fitment and filtering.

### 3.3 Part Categorization
- Parts are organized by category and subcategory (e.g., "Electrical" > "Alternator").
- Categories and subcategories are stored in the database and can be extended.

### 3.4 Search & Filtering (Updated)
- Search and ad discovery are powered by semantic vector embeddings using Google Gemini (gemini-embedding-001) and Qdrant vector database.
- Each ad is encoded as a vector embedding at creation or update, stored in Qdrant with metadata (created_at, click_count, parent_company, parent_company_country, etc.).
- **Enhanced Brand Clustering:** Embeddings include parent company name and country information to improve clustering of related automotive brands (e.g., Ford/Mercury, Toyota/Lexus, Honda/Acura). This ensures ads for makes with the same parent company are semantically grouped together for better search relevance.
- **Parent Company Integration:** The system maintains a simplified parent company relationship where each make has one primary parent company (chosen for historical significance rather than current ownership). This enables better semantic understanding and brand clustering in vector embeddings.
- **Vector Search Metadata:** Each ad embedding includes comprehensive metadata for filtering and navigation:
  - **Tree Navigation Fields:** make, years (array), models (array), engines (array), category, subcategory (optional)
  - **Pricing:** price (for filtering/sorting)
  - **Geographic:** geo coordinates (lat/lon) when available
  - **Engagement:** click_count, created_at
  - **Brand Information:** parent_company, parent_company_country
- **Vector Search Filtering:** The system supports sophisticated filtering at the Qdrant vector database level:
  - **Tree Navigation Filtering:** Filter by make, year, model, engine, category using exact matches
  - **Price Range Filtering:** Filter by price ranges (implemented via metadata)
  - **Geographic Filtering:** Filter by location/radius (placeholder implementation)
  - **Combined Filters:** Multiple filters can be applied simultaneously using Qdrant's filter system
- **Search Flow:**
  - If a user enters a query (`q`), the query is embedded and Qdrant is used to find the most semantically similar ads.
  - If a user is logged in and `q` is empty, a personalized embedding is generated by aggregating embeddings from their recent search queries, clicked ads, and bookmarked ads (bookmarks weighted most heavily). This user embedding is stored in the database and updated after every search. Qdrant is queried with this user embedding for a personalized feed.
  - If not logged in and `q` is empty, the feed is built using a combination of recency, click count, and embedding-based diversity (e.g., cluster sampling or diversity maximization in embedding space).
- **Tree View Integration:** The tree navigation system uses vector search with filters to populate tree nodes, ensuring semantic relevance while maintaining structured navigation.
- Results are ranked by vector similarity, with recency and popularity as secondary factors.
- **Infinite scroll and pagination:**
  - The system supports infinite scroll for ad results using Qdrant's offset-based pagination for consistent results across pages.
  - Pagination uses a simple cursor format (base64-encoded offset) that tracks the current position in the result set.
  - This ensures that new ads added between page loads don't cause duplicates or gaps in the results.
- All search and feed functionality is powered by Qdrant vector search only.
- **[Complete]** All vector embedding and personalization features are implemented, including persistent user embeddings and automatic updates after user activity.

### 3.5 Caching System
- **B2 Token Cache:** Caches Backblaze B2 download authorization tokens to reduce API calls and improve performance when serving ad images. Tokens are cached by directory prefix (e.g., "22/") and automatically expire based on B2's token expiry settings.
- **Specialized Embedding Caches:** The system now uses three specialized caches for different embedding types:
  - **Query Cache (1 hour TTL):** Caches vector embeddings for user search queries to improve search performance and reduce API calls to Google Gemini. This cache stores the embedding vectors themselves and uses memory-based cost calculation (4 bytes per float32).
  - **User Cache (24 hour TTL):** Caches personalized user embeddings generated from their search history, clicked ads, and bookmarks. This eliminates the need for database storage and provides fast access to user preferences.
  - **Site Cache (6 hour TTL):** Caches site-level embeddings calculated from popular ads to provide anonymous users with relevant default search results.
- **Cache Implementation:** All caches use a unified cache abstraction that provides:
  - Generic type-safe cache operations (Get, Set, Clear, Wait)
  - Standardized cache statistics for admin monitoring (hits, misses, hit rate, memory usage)
  - Consistent configuration across all cache instances
  - Clean abstraction that doesn't leak underlying implementation details
- **Cache Management:** Admin interface provides real-time statistics for all three caches and the ability to clear caches for maintenance purposes.
- **Performance Benefits:** Specialized caching significantly reduces API latency and costs while improving user experience through faster response times. The three-cache architecture ensures optimal TTL settings for each embedding type.

### 3.6 API Endpoints
- RESTful endpoints for CRUD operations on ads and for fetching vehicle/part data for dynamic forms.
- **SMS Webhook Endpoint**: `/api/sms/webhook` - Processes Twilio SMS status callbacks and user responses.
- **Twilio Integration**: Unified platform for both SMS and email notifications using Twilio's services.
- **Registration Endpoints**: 
  - `POST /api/register/step1` - Handles initial registration with phone verification
  - `POST /api/register/verify` - Processes verification code and completes registration
- **User Settings Endpoints**:
  - `POST /api/change-password` - Updates user password
  - `POST /api/update-notification-method` - Updates user notification method preference
  - `POST /api/notification-method-changed` - Handles dynamic UI updates when notification method changes
  - `POST /api/delete-account` - Deletes user account
- **Messaging Endpoints**:
  - `GET /messages` - Main messages page showing all conversations
  - `GET /messages/:id` - Specific conversation page with message history
  - `POST /messages/:id/send` - Send a new message in a conversation
  - `GET /messages/start/:adID` - Start a new conversation about an ad
  - `GET /api/messages/:action` - API for conversations and unread counts
- **Rock System Endpoints**:
  - `GET /api/ad-rocks/:id` - Get rock information for an ad
  - `POST /api/throw-rock/:id` - Throw a rock at an ad
  - `GET /api/ad-rocks/:id/conversations` - View rock conversations for an ad
  - `POST /api/resolve-rock/:id` - Resolve a rock dispute and return the rock

### 3.7 Rock System for Dispute Resolution
- **User Rock Inventory**: New users receive 3 rocks upon account verification. Rocks are a limited resource for marking disputes or complaints about ads.
- **Rock Throwing**: Users can throw rocks at ads they believe violate policies or have quality issues. Each rock creates a conversation with the ad owner.
- **Rock Management**: Once thrown, a rock is attached to the ad and the user's rock count decreases. Rocks can only be returned by the ad owner after dispute resolution.
- **Dispute Resolution**: Rock conversations are publicly viewable, allowing transparency in dispute resolution. Ad owners can work with rock throwers to resolve issues.
- **Search Penalties**: Ads with rocks are penalized in search results, with more rocks resulting in heavier penalties. This encourages quality maintenance.
- **Rock UI**: Rocks are displayed as icons on ads with counts. Users can view rock conversations and resolve disputes through the messaging system.

### 3.8 Modern UI/UX
- Modern, accessible web UI using Tailwind CSS and HTMX for dynamic updates.
- Form validation and user feedback for all actions.
- **Ad timestamps are displayed in the user's local timezone, using browser-provided timezone information when available.**
- **Settings Page**: Comprehensive user settings management including:
  - Notification method preferences (SMS, Email, Signal) with radio button selection
  - Conditional email address field (always visible, enabled only when email is selected)
  - Password change functionality
- **Ads Management Page**: Centralized ads management with three sub-sections:
  - **Bookmarked**: Shows ads the user has bookmarked for later reference
  - **Active**: Shows the user's currently active ads with option to create new ads
  - **Deleted**: Shows the user's deleted/archived ads that can be restored if needed
  - Tab-based navigation using HTMX for seamless switching between sections
  - User menu item changed from "Bookmarks" to "Ads" to reflect expanded functionality

### 3.8 User-to-User Messaging System
- **Per-Ad Conversations**: Users can start conversations about specific ads by clicking a message button on expanded ad views.
- **Message Button**: Appears on all ad cards (except user's own ads) when logged in, redirects to conversation page.
- **Conversation Management**: 
  - New conversations are automatically created when messaging about an ad for the first time
  - Existing conversations show full message history
  - Messages are displayed in chronological order with sender identification
- **Navigation**: Messages link added to main header navigation for logged in users
- **Security**: Users cannot message themselves (guarded against in backend)
- **Notifications**: 
  - SMS notifications via Twilio include brief message preview and clickable link to conversation
  - Email notifications via Twilio SendGrid show conversation context and direct link to inbox
  - Notifications respect user's preferred notification method (SMS/Email)
  - Unified Twilio platform for both SMS and email delivery
  - Robust error handling and graceful degradation when services are unavailable
  - Phone number validation and proper error logging for debugging
- **Database Schema**: Normalized tables for conversations and messages with proper indexing
- **HTMX Integration**: All messaging functionality uses HTMX for seamless user experience without JavaScript
  - Account deletion options
  - Bookmarked ads management
- UI elements that require authentication (such as "New Ad", "Edit Ad", or "Delete Ad" buttons) are shown in a disabled state or with limited interactivity for unauthenticated users, providing clear feedback that login is required to access these features.

### 3.8 SMS Verification & Two-Factor Authentication (2FA)
- **Phone Number Verification**: Users must verify their phone number during registration using SMS verification codes.
- **Verification Code System**: 
  - 6-digit numeric codes sent via SMS
  - 10-minute expiration window
  - Maximum 3 attempts per code
  - Codes are invalidated after successful verification or expiration

### 3.9 User Notification Preferences
- **Notification Method Selection**: Users can choose their preferred notification method from:
  - Text to phone number - displays the user's actual phone number
  - Email to: - displays email input field below (no redundant label)
  - Signal
- **Email Address Storage**: When email is selected as the notification method, users can provide and save their email address
- **Email Validation**: Email addresses are validated for proper format (contains @, valid domain structure, etc.)
- **Required Field**: Email address is required when email notifications are selected
- **Error Handling**: Validation errors are displayed inline within the notification preferences section
- **Success Feedback**: Users receive confirmation when preferences are successfully updated
- **Settings Management**: Users can update their notification preferences through the settings page
- **Future Extensibility**: The system is designed to support additional notification methods as they become available
- **Twilio Integration**: SMS delivery through Twilio with comprehensive status tracking and webhook handling.
- **SMS Status Webhooks**: Real-time monitoring of SMS delivery status including:
  - Delivery confirmations
  - Failed deliveries
  - Undelivered messages
  - User STOP responses
- **STOP Response Handling**: When users reply "STOP" to SMS messages:
  - All pending verification codes are immediately invalidated
  - User is effectively blocked from completing registration
  - Compliance with SMS opt-out regulations
- **Failed Delivery Handling**: Automatic cleanup when SMS delivery fails:
  - Verification codes are invalidated for failed deliveries
  - Prevents registration completion with invalid phone numbers
- **Account Cleanup & Security**: Automatic account deletion for failed verification attempts:
  - Tracks failed verification attempts within a 24-hour window
  - Automatically deletes accounts after 5 failed verification attempts
  - Removes all associated data (verification codes, partial user records)
  - Prevents abuse and maintains system security
- **Registration Flow**: Two-step registration process:
  - Step 1: Username, phone number, and SMS consent
  - Step 2: Verification code entry and password creation
  - Proper page navigation between steps (no HTMX result div updates)
- **Required Field Validation**: Username and phone number are mandatory form fields with server-side validation.
- **SMS Consent**: Users must explicitly agree to receive informational text messages to proceed with registration.

### 3.7a In-Place Ad Card Expand/Collapse (SPA-like UX)
- Users can expand an ad card in-place to view ad details without leaving the list or tree view.
- Clicking "Expand" on an ad card loads the ad detail view in-place using htmx, replacing the card with the detail partial.
- The detail view includes a "Collapse" button to return to the original card view in-place.
- No full page reload or navigation is required; browser back/forward preserves the previous state.
- This is implemented using htmx and Gomponents, with no custom JavaScript.
- New endpoints:
  - `GET /ad/card/:id` — Returns the ad card partial for in-place collapse.
  - `GET /ad/detail/:id` — Returns the ad detail partial for in-place expand.
- This provides a seamless, SPA-like user experience while maintaining server-side rendering and progressive enhancement.

### 3.7b Ad Click Count Tracking
- Each ad tracks the number of times it has been viewed (clicked) by users, and the date/time of the last click.
- The click count and last clicked date/time are displayed on the ad card and detail views in the UI.
- Clicks are incremented in the database each time an ad is viewed.
- User-specific click tracking is also supported, allowing for analytics on unique user engagement, including the date/time of the last click by that user.

### 3.8 Ad Posting
- Posting an ad is free for all users.
- No cost or payment system is required.
- Users can post ads without any financial barriers.

### 3.9 Paid Advertising & Promotion
- Advertisers pay for prominent placement in search results.
- Paid ads are visually distinct (special background).
- The first paid ad always appears at the top of search results; additional paid ads are interleaved at pagination boundaries (e.g., after each page of results).
- Clicks on paid ads charge the advertiser.
- Paid ads are intermixed with regular ads, but clearly marked.

### 3.9 LLM-based Username Moderation
- During user registration, the system uses a Large Language Model (LLM) to check the proposed username for appropriateness.
- The LLM evaluates whether the username is offensive, hateful, or inappropriate for a public site.
- Car-guy humor, puns, and light-hearted jokes are allowed, but anything that would be considered offensive, hateful, or discriminatory in a public forum is not allowed.
- If the username is not allowed, the LLM provides a brief explanation; if allowed, registration proceeds.
- This moderation step is in addition to uniqueness checks (e.g., no duplicate usernames).

### 3.10 User Registration & Authentication
- **Registration Requirements:**
  - Users must provide:
    - **Username** (must be unique, subject to LLM moderation for appropriateness; see 3.9)
    - **Phone number** (must be unique, used for account recovery and verification)
    - **Password** (stored securely using strong hashing, e.g., bcrypt)
  - Registration form validates all fields are present and unique.
  - Usernames are checked by an LLM for appropriateness (car-guy humor allowed, but offensive/inappropriate names are rejected with a clear message).

- **Login Requirements:**
  - Users log in with their **username** and **password**.
  - On successful login, a secure session is established (e.g., via a session cookie).
  - Incorrect username or password results in a generic error message (do not reveal which field is incorrect).

- **Logout:**
  - Users can log out, which clears their session.
  - **Logout is performed via a POST form (not a GET link), following security best practices.**

- **Security:**
  - Passwords are never stored in plain text.
  - Passwords are hashed using Argon2id with a unique salt before being stored in the database.
  - Session management is handled via an HTTP-only cookie that stores the user's `user_id` upon successful login. This cookie is used to authenticate the user for subsequent requests.
  - Phone numbers are not displayed publicly.
  - Session cookies are HTTP-only to prevent access from client-side scripts.

### 3.11 User Settings & Account Management
- Authenticated users can access a dedicated settings page (via a gear icon in the navigation bar) to manage their account.
- The settings page allows users to:
  - Change their password (current password required for confirmation).
  - Delete their account (with confirmation prompt).
- The settings page is accessible only to logged-in users.
- UI/UX: The gear icon is shown in the user navigation bar on all pages when logged in.
- **Account Deletion:**
  - When a user deletes their account:
    - User data is archived (not deleted) for historical record keeping
    - All user's ads are archived (not deleted)
    - The user and their ads are no longer visible in the main application
    - This action is irreversible and requires password confirmation

### 3.12 Data Archiving & Admin Interface
- **Data Archiving:**
  - The system uses soft deletes to preserve data for historical records
  - When users or ads are "deleted", they are marked with a `deleted_at` timestamp rather than being physically removed
  - This approach preserves all data for auditing while removing it from active use
  - Archived data includes:
    - User profiles (marked with deleted_at in User table)
    - User's ads (marked with deleted_at in Ad table)
    - Vehicle associations remain intact in the single AdCar table
  - Benefits of soft delete approach:
    - No data duplication between active and archived tables
    - Simpler database schema and maintenance
    - Consistent vehicle data access for both active and archived ads
    - Easier restoration of accidentally deleted content

- **Admin Interface:**
  - Administrators can access archived data through dedicated endpoints
  - Admin features include:
    - View archived users with deletion dates (filtered by deleted_at IS NOT NULL)
    - View archived ads (filtered by deleted_at IS NOT NULL)
    - Search archived data by various criteria
    - Export archived data for analysis
    - Restore archived ads by clearing the deleted_at field
    - Restore archived users by clearing the deleted_at field
  - Admin access is restricted by role-based authentication

### 3.13 Ad Card UX (2024-06-xx)
- All ad card views (list, grid, tree, bookmarks, etc.) show a bookmark icon on each card.
- The bookmark icon is always visible and is the only clickable area that does not navigate to the ad detail page.
- Clicking anywhere else on the ad card navigates to the ad detail page (`/ad/{id}`).
- There are no expand/collapse icons or in-place expansion; ad details are shown on a separate page.

### 3.14 Ad Editing
- Ad editing is simplified to allow only essential changes after ad creation.
- **Editable Fields:** Once an ad is created, users can only edit:
  - **Price:** Can be updated at any time
  - **Location:** Can be updated to reflect part relocation
  - **Description:** Users can only add to the description (not replace it)
    - Each addition is timestamped in the format `[YYYY-MM-DD HH:MM]`
    - Additions are appended to the existing description with timestamps
    - Total description length must remain under 500 characters
- **Non-Editable Fields:** The following fields cannot be changed after creation:
  - Title, Make, Years, Models, Engines, Categories, Subcategories, Images
- **In-Place Modal Editing:** Ad owners can edit fields directly in the detail view
  - Editable fields show a small edit icon (using /edit.svg) on hover
  - Clicking on a field or its edit icon opens a modal dialog for editing
  - Modal dialogs provide a focused editing experience for each field:
    - **Price Modal:** Simple number input for updating the price
    - **Location Modal:** Text input for updating location (resolved via Grok API)
    - **Description Modal:** Shows current description and provides textarea for additions with timestamp
  - After saving, the modal closes and the ad detail view updates via HTMX
  - Each field update triggers a separate API endpoint and vector embedding update

### 3.14a Ad Sharing
- **Share Button:** All ad detail pages include a share button (using /images/share.svg) visible to all users
  - Opens a modal dialog showing the ad's full URL (`/ad/{id}`)
  - Includes a copy-to-clipboard button (using /images/copy.svg) that copies the full URL
  - Copy functionality uses JavaScript `navigator.clipboard.writeText()` API
  - Displays temporary success feedback after copying
  - Modal can be closed by clicking outside or using the close button
- **Visibility:** Share button is visible to all users (logged in or not) on both active and archived ads

### 3.14b Ad Duplication
- **Duplicate Button:** All ad detail pages include a duplicate button (using /images/duplicate.svg) visible to logged-in users
  - Links to `/duplicate-ad/{id}` to create a new ad based on an existing one
  - Pre-fills the new ad form with selected fields from the original ad:
    - **Copied Fields:** Title, Make, Years, Models, Engines, Category, Subcategory
    - **Not Copied:** Description, Price, Location, Images
  - Server-side rendering: All form fields (dropdowns, checkboxes) are pre-populated on page load
  - No JavaScript required - pure HTMX/server-side rendering approach
  - Allows users to create similar ads without re-entering vehicle and part information
- **Implementation:** Separate `HandleDuplicateAd` handler fetches original ad data and renders `DuplicateAdPage` with all vehicle/part options pre-loaded and pre-selected
- **Visibility:** Duplicate button is only visible to logged-in users on both active and archived ads
- **Authentication:** Unauthenticated users who access the duplicate URL directly are redirected to the login page (via authentication middleware)
- **Use Cases:** 
  - Sellers can quickly list multiple similar parts
  - Users can repost expired ads with updated information
  - Archived ads can be duplicated to create new listings

### 3.15 Ad Location
- Each ad now has an optional location field to track where parts are located. This field is stored in the database and can be set or edited by the user. If present, it is displayed on the ad details page.
- **Grok API Location Resolution:** When users enter location information (address, city, zip code, or country), the system uses the Grok API to intelligently resolve and standardize the location data:
  - **Structured Location Data:** Grok translates user input into standardized city, admin_area (state/province), and country fields
  - **Geographic Coordinates:** Grok also provides latitude and longitude coordinates for the resolved location
  - **Database Storage:** Location data is stored in the Location table with coordinates for future geographic search capabilities
  - **Vector Metadata:** Coordinates are included in vector embeddings for geographic filtering and proximity-based search
  - **Country Code Standardization:** Countries are stored as 2-letter ISO codes (e.g., "US", "CA", "GB") for consistency
  - **Admin Area Formatting:** US and Canadian states/provinces use official 2-letter codes (e.g., "OR", "NY", "BC", "ON"), while other countries use full names

---

## 4. Technology Stack

The platform is built with the following technologies:

- **Backend:** Written in Go, using the [Fiber](https://gofiber.io/) web framework for high performance. Fiber handles routing, middleware, sessions, authentication, and request/response logic.
- **HTML Generation:** Uses Gomponents for type-safe, composable UI components in Go.
- **Frontend:** Tailwind CSS and HTMX for responsive, dynamic user interfaces.
- **Vector Search:** Google Gemini (gemini-embedding-001) for semantic embeddings and Qdrant vector database for similarity search and filtering.
- **Database:** SQLite with comprehensive schema for vehicle data, user management, and transaction tracking. Database operations use [sqlx](https://github.com/jmoiron/sqlx) for enhanced type safety and reduced boilerplate code.
- **Background Processing:** Go goroutines for vector embedding generation and user personalization updates.

---

## 5. User Stories

- As a seller, I want to create a new ad for a part, specifying the exact vehicles it fits, so buyers can find it easily.
- As a buyer, I want to search for parts by my car's make, year, model, and engine, so I only see relevant ads.
- As a user, I want to browse categories and subcategories to discover available parts.
- As a seller, I want to edit or delete my ads if details change or the part is sold.
- As a user, I want fast, accurate search results and a modern, easy-to-use interface.
- As a user, I want to manage my account settings, including changing my password or deleting my account, from a dedicated settings page.

---

## 6. Data Model (Simplified)

### Database Tables
- **Make**: id, name, parent_company_id
- **ParentCompany**: id, name, country
- **Year**: id, year
- **Model**: id, name
- **Engine**: id, name
- **Car**: id, make_id, year_id, model_id, engine_id
- **PartCategory**: id, name
- **PartSubCategory**: id, category_id, name
- **Location**: id, raw_text, city, admin_area, country, latitude, longitude
- **Ad**: id, title, description, price, created_at, deleted_at, subcategory_id, user_id, location_id, image_count, click_count, last_clicked_at, has_vector
- **AdCar**: ad_id, car_id (single table for all vehicle associations)
- **User**: id, name, phone, password_hash, password_salt, password_algo, phone_verified, verification_code, notification_method, email_address, created_at, is_admin, deleted_at
- **UserSearch**: id, user_id (nullable), query_string, created_at

- **BookmarkedAd**: user_id, ad_id, bookmarked_at
- **UserAdClick**: ad_id, user_id, click_count, last_clicked_at
- **PhoneVerification**: id, phone, verification_code, expires_at, attempts, created_at
- **UserRock**: id, user_id, rock_count, created_at, updated_at
- **AdRock**: id, ad_id, thrower_id, conversation_id, created_at, resolved_at, resolved_by

### Data Archiving Strategy
- **Soft Delete for Ads**: Ads are marked as archived by setting `deleted_at` timestamp instead of being moved to separate tables
- **Soft Delete for Users**: Users are marked as archived by setting `deleted_at` timestamp instead of being moved to separate tables
- **Unified Vehicle Data**: All vehicle associations remain in the single `AdCar` table, accessible for both active and archived ads
- **Benefits**: 
  - Eliminates data duplication between active and archived states
  - Simplifies database schema and maintenance
  - Maintains referential integrity for vehicle associations
  - Enables easy restoration of archived content
  - Consistent archiving approach across users and ads

### Vector Database (Qdrant)
- **Ad Embeddings**: Stored with comprehensive metadata including:
  - Tree navigation fields (make, years, models, engines, category, subcategory (optional))
  - Pricing information (price)
  - Geographic coordinates (lat/lon) when available
  - Engagement metrics (click_count, created_at)
  - Brand information (parent_company, parent_company_country)

### Technical Implementation Details
- **Ad Archiving**: Implemented via soft delete using `deleted_at` DATETIME field in Ad table
- **User Archiving**: Implemented via soft delete using `deleted_at` DATETIME field in User table
- **Vehicle Data Access**: Single `getAdVehicleData()` function works for both active and archived ads
- **Query Optimization**: All ad and user queries automatically filter out archived items using `WHERE deleted_at IS NULL`
- **Archive Functions**: 
  - `GetArchivedAd()` uses unified `getAd()` function then loads `deleted_at` separately
  - `GetArchivedUser()` uses unified `getUser()` function then loads `deleted_at` separately
  - Archive/Restore operations use simple UPDATE statements instead of complex table operations
- **Database Schema**: Simplified from separate `ArchivedAd`/`ArchivedAdCar` and `ArchivedUser` tables to single tables with soft delete

### Database Layer Implementation (sqlx)
- **sqlx Integration**: The system uses [sqlx](https://github.com/jmoiron/sqlx) for enhanced database operations with automatic struct scanning and reduced boilerplate code.
- **Struct Tags**: All database models use `db` struct tags for automatic field mapping (e.g., `db:"id"`, `db:"created_at"`).
- **Query Methods**: Database operations leverage sqlx's `Select()`, `Get()`, and `NamedExec()` methods for type-safe operations.

See `schema.sql` for full schema and indexes.

**Note:** The system now uses soft deletes for both ads and users (deleted_at field), eliminating the need for separate archived tables and providing a consistent archiving approach.

---

## 7. API & Endpoints

- `GET /` — Home/search page
- `GET /new-ad` — New ad form
- `GET /ad/{id}` — View ad details
- `GET /search` — Search ads (supports query and cursor for pagination)
- `GET /api/makes` — List all makes
- `GET /api/years?make=...` — List years for a make
- `GET /api/models?make=...&years=...` — List models for make/years
- `GET /api/engines?make=...&years=...&models=...` — List engines for make/years/models
- `POST /api/new-ad` — Create new ad
- `POST /api/update-ad-price/:id` — Update ad price
- `POST /api/update-ad-location/:id` — Update ad location
- `POST /api/update-ad-description/:id` — Add to ad description
- `DELETE /delete-ad/{id}` — Delete ad
- `GET /register` — Registration form
- `POST /api/register` — Register new user
- `GET /login` — Login form
- `POST /api/login` — User login
- `POST /logout` — User logout
- `GET /settings` — User settings page (change password, delete account)
- `POST /api/change-password` — Change user password
- `POST /api/delete-account` — Delete user account

### Rock System Endpoints
- `GET /api/ad-rocks/:id` — Get rock information for an ad
- `POST /api/throw-rock/:id` — Throw a rock at an ad
- `GET /api/ad-rocks/:id/conversations` — View rock conversations for an ad
- `POST /api/resolve-rock/:id` — Resolve a rock dispute and return the rock

### Admin Endpoints
- `GET /admin/b2-cache` — View B2 cache statistics and management
- `POST /api/admin/b2-cache/clear` — Clear B2 cache
- `POST /api/admin/b2-cache/refresh` — Refresh B2 download token for specific prefix
- `GET /admin/embedding-cache` — View embedding cache statistics and management
- `POST /api/admin/embedding-cache/clear` — Clear embedding cache

---

## 8. Non-Functional Requirements

- **Performance**: Fast search and filtering, efficient DB queries, indexed tables.
- **Scalability**: Designed for extensibility (e.g., user accounts, more part attributes).
- **Security**: Input validation, confirmation for destructive actions.
- **Reliability**: Transactional DB operations for ad CRUD.
- **Maintainability**: Modular Go codebase, clear separation of concerns.
- **Accessibility**: Responsive, accessible UI components.

---

## 9. Licensing

- BSD 3-Clause License (see LICENSE file)

---

## 10. Open Questions / Future Work

- User authentication and account management
- Messaging between buyers and sellers
- Image uploads for ads
- Advanced analytics and reporting
- Internationalization/localization
- Admin dashboard for moderation


---







---

## Database Rebuild Command

A new command in `cmd/rebuild_db/` will:
- Delete any existing `project.db`.
- Create a new `project.db` using the schema in `schema.sql`.
- Import vehicle data from `make-year-model.json`.
- Import part category/subcategory data from `part.json` (now located in `cmd/rebuild_db/`).

This command ensures the database is always rebuilt from a clean slate and is idempotent. 